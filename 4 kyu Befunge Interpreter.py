'''
Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

Your task is to write a method which will interpret Befunge-93 code! 
Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane;
your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen!
There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, 
you need not be concerned with code size. Befunge-93 supports the following instructions (from https://en.wikipedia.org/wiki/Befunge):

    0-9 Push this number onto the stack.
    + Addition: Pop a and b, then push a+b.
    - Subtraction: Pop a and b, then push b-a.
    * Multiplication: Pop a and b, then push a*b.
    / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
    % Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
    ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
    ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
    > Start moving right.
    < Start moving left.
    ^ Start moving up.
    v Start moving down.
    ? Start moving in a random cardinal direction.
    _ Pop a value; move right if value = 0, left otherwise.
    | Pop a value; move down if value = 0, up otherwise.
    " Start string mode: push each character's ASCII value all the way up to the next ".
    : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
    \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
    $ Pop value from the stack and discard it.
    . Pop value and output as an integer.
    , Pop value and output the ASCII character represented by the integer code that is stored in the value.
    # Trampoline: Skip next cell.
    p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
    g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
    @ End program.
     (i.e. a space) No-op. Does nothing.

The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.

Here's an example:

>987v>.v
v456<  :
>321 ^ _@

will create the output 123456789.

So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:

"123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")

This test case will be added for you.

'''
import random

def get_direction(symbol):
    if symbol == ">":
        return "right"
    elif symbol == "<":
        return "left"
    elif symbol == "^":
        return "up"
    elif symbol == "v":
        return "down" 
    elif symbol == "?":
        return random.choice(["right", "left", "up", "down"])

def move_pointer(x, y, direction):
    if direction == "right":
        x += 1
    if direction == "left":
        x -= 1
    if direction == "up":
        y -= 1
    if direction == "down":
        y += 1
    return x, y

def math_operation(stack, symbol):
    if symbol == "+":
        a = stack.pop(0)
        b = stack.pop(0)
        stack.insert(0, a + b)
        
    if symbol == "-":
        a = stack.pop(0)
        b = stack.pop(0)
        stack.insert(0, b - a)

    if symbol == "*":
        a = stack.pop(0)
        b = stack.pop(0)
        stack.insert(0, a * b)

    if symbol == "/":
        try:
            a = stack.pop(0)
            b = stack.pop(0)
            stack.insert(0, b // a)
        except ZeroDivisionError:
            stack.insert(0, 0)

    if symbol == "%":
        try:
            a = stack.pop(0)
            b = stack.pop(0)
            stack.insert(0, b % a)
        except ZeroDivisionError:
            stack.insert(0, 0)

    # ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
    if symbol == "!":
        if stack.pop(0) == 0:
            stack.insert(0, 1)
        else:
            stack.insert(0, 0)

    # ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
    if symbol == "`":
        a = stack.pop(0)
        b = stack.pop(0)
        if b > a:
            stack.insert(0, 1)
        else:
            stack.insert(0, 0)

    return stack

def interpret(code):
    print(code)
    output = ""
    code = code.split("\n")
    x = 0
    y = 0
    direction = "right"
    stack = []
    symbol = ""
    stringMode = False
    skip = False

    while symbol != "@":
        symbol = code[y][x]
        
        if skip:
            skip = not skip
            x, y = move_pointer(x, y, direction)
            print(direction, symbol, stack, output, x, y)
            continue

        if symbol in ('<>^v?'):
            direction = get_direction(symbol)

        if symbol == '"':
            stringMode = not stringMode
            x, y = move_pointer(x, y, direction)
            print(direction, symbol, stack, output, x, y)
            continue

        if stringMode:
            stack.insert(0, ord(symbol))
            x, y = move_pointer(x, y, direction)
            print(direction, symbol, stack, output, x, y)
            continue

        if symbol.isdigit():
            stack.insert(0, int(symbol))

        if symbol in ('+-*/%!`'):
            stack = math_operation(stack, symbol)

        # . Pop value and output as an integer.
        if symbol == ".":
            output += str(stack.pop(0))
        
        # , Pop value and output the ASCII character represented by the integer code that is stored in the value.
        if symbol == ",":
            output += chr(stack.pop(0))
        
        # : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
        if symbol == ':':
            if len(stack) == 0:
                stack.insert(0, 0)
            else:
                stack.insert(0, stack[0])
        
        # \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
        if symbol == '\\':
            if len(stack) == 1:
                stack.insert(0, 0)
            else:
                stack[0], stack[1] = stack[1], stack[0]

        # $ Pop value from the stack and discard it.
        if symbol == '$':
            stack.pop(0)

        # # Trampoline: Skip next cell.
        if symbol == '#':
            skip = True
        
        # p A "put" call (a way to store a value for later use). 
        # Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
        if symbol == 'p':
            a = stack.pop(0)
            b = stack.pop(0)
            c = stack.pop(0)
            code[a] = code[a][:b] + chr(c) + code[a][b+1:]
        
        # g A "get" call (a way to retrieve data in storage). 
        # Pop y and x, then push ASCII value of the character at that position in the program.
        if symbol == 'g':
            a = stack.pop(0)
            b = stack.pop(0)
            stack.insert(0, ord(code[a][b]))

        # _ Pop a value; move right if value = 0, left otherwise.
        if symbol == '_':
            if stack.pop(0) == 0:
                direction = "right"
            else:
                direction = "left"
        
        # | Pop a value; move down if value = 0, up otherwise.
        if symbol == '|':
            if stack.pop(0) == 0:
                direction = "down"
            else:
                direction = "up"

        x, y = move_pointer(x, y, direction)
        print(direction, symbol, stack, output, x, y)

    return output

print(interpret("01->1# +# :# 0# g# ,# :# 5# 8# *# 4# +# -# _@")) # 01->1# +# :# 0# g# ,# :# 5# 8# *# 4# +# -# _@
